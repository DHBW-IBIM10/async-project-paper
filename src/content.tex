

\title{\papertitle}
\author{Rocco Schulz, Max VÃ¶kler, Joe Boden,\\ Robert Wawrzyniak, Can Paul Bineytioglu\\\\
	Corporate State University\\Baden-Wuerttemberg - Stuttgart}

\date{\today}

\begin{document}

\maketitle


\begin{abstract}
This paper evaluates asynchronous server technologies. Strenghts and weaknesses
of asynchronous programming models are elaborated and a proof of concept 
based on node.js and vert.x is used to evaluate non-functional attributes such as
maintainability. \ldots
\end{abstract}

\section{Introduction}
In traditional Web applications a connection's lifespan starts with a request and
ends with the servers response. Each connection is assigned a thread which
processes the request and terminates afterwards.
However in order to allow real-time\footnote{proper real time, as opposed to
ancient definitions. TODO: reference} communication between client and server it
is necessary to extend the connection's lifespan to the duration of the whole
session which results in many simultaniously open connections.
Assigning one thread for each open connection would cause a large overhead for
the server even though most threads would be inactive. This is due to the data
associated with each thread and the process of switching between all
threads.\footnote{TODO: there's probably a better term than switching}\\
Relatively young frameworks such as Node.js and Vert.x try to address this issue 
by providing a completely asynchronous programming model which allows associating
multiple simultanious connections with a single thread by using an event-driven approach.

%Goal of this paper and structure
This paper elaborates the concepts behind these young frameworks and analyses their 
technical strengths and weaknesses. Furthermore non-functional attributes will be
evaluated based on two sample implementations in Node.js  and Vert.x.

\section{Setting the context}
\label{setting_the_context}

\subsection{Comparison between Asynchronous and Synchronous Processing}
\label{comparison}
TODO: Benefits of this approach vs synchronous (literature: distributed systems)

%Synchronous calls -> idling threads -> 
A common case in programming is access to I/O.
In synchronous processing a running thread needs to wait for the completion of
the I/O operation before it can continue.
The thread is in an idle state while it is waiting which allows another process 
or thread to occupy the CPU in the meanwhile.\\

% writing multithreaded code is not trivial
In multithreaded applications several threads can run simultaniously within one
process. Several threads can access shared memory concurrently which can
cause inconcistent states. This can be avoided by synchronizing threads - e.g.
with locks. This means that programmers need to take into account every possible
execution order to effectively avoid program defects. This can be time consuming
and often results in error-prone code.\footcite[Cf.][TODO]{Breshears_2009}

A typical synchronous call is provided in listing \ref{lst:synchronous_call}. The
contents of a file are read and displayed afterwards. The programm is blocked until the
read operation has finished.

% reading a file and displaying it, pseudo code
\lstinputlisting[caption={Pseudocode: Synchronously reading and displaying a file's contents},
label=lst:synchronous_call]{lst/synchronous_call.txt}


Asynchronous programming style uses a different concept. The flow of an
application is determined by events, which is why this style is also called
event-driven programming. In listing \ref{lst:asynchronous_call} the call
to the \textit{readAsText} function is done asynchronously. There is no
return value - instead an event handler is provided as a second argument.
This function is also referred to as a callback function. It is called
as soon as the read operation has completed.

% same example as above but with callbacks / events
\lstinputlisting[caption={Pseudocode: Asynchronously reading and displaying a file's contents},
label=lst:asynchronous_call]{lst/asynchronous_call.txt}

This concept is coupled with an event loop, which is a single thread that
is running inside the main process.
The loop constantly checks for new events. When an event is detected, the loop
invokes the corresponding callback function. The callback is processed in the same thread
which means that there is at most one callback running at a time. The
event loop continues when the callback has completed.

% programmer doesnt need to worry about concurrency at this point
% every request is handled, however io intense callbacks could cause 
% slow event processing. 
% it is the programmers task to write light callbacks that can be
% processed quickly
% see: http://developer.yahoo.com/blogs/ydn/posts/2010/10/understanding-the-event-loops-and-writing-great-code-for-node-js-part-1/



\subsection{Existing Asynchronous Frameworks}
\label{existing_frameworks}
list of recent asynchronous programming models and frameworks such as vert.x,
node.js, twisted, EventMachine, etc.

A table with short descriptions should be sufficient.

\begin{table}[h]
\centering
\begin{tabular*}{\textwidth}{p{0.2\textwidth} p{0.23\textwidth} p{0.47\textwidth}}
\toprule
\textbf{Name} & \textbf{Language/s} & \textbf{Description} \\
\midrule
Node.js			& JavaScript		& Based on Googles V8 engine\\
Vert.x			& JavaScript, Java, Python, Groovy, Ruby, Coffeescript		
									& JVM based, inspired by node.js\\
Twisted			& Python			& Python stuff, not fully threadsafe\\
EventMachine	& Ruby				& Event-driven software system for concurrent programming.\\
\bottomrule 
\end{tabular*}
  \captionof{table}{Existing asynchronous programming frameworks}
  \label{tab:existing_frameworks}
\end{table}



\section{Areas of Application}
\label{areas_of_application}

The non-blocking nature of asynchronous calls is important in all types of
applications that need to handle a large number of requests in real time.



\section{Exemplary Implementations}
\label{exemplary_implementations}

A simple web form application has been implemented in Node.js and Vert.x to
further analyze non-functional requirements and collect practical experience
with these frameworks.

\subsection{Software Description}
\label{software_description}
Brief description of the insurance fee calculator

\subsection{Software Design}
\label{software_design}
High level design\\
Interface description, and differences between Node.js and Vert.x

\subsection{Software Implementation}
\label{software_implementation}
Complications or any other notes on the implementation process that might be of
importance for the evaluation.





\section{Evaluation of Non-functional Attributes}
\label{evaluation_nonfunctional}





\section{Conclusion}
\label{conclusion}




